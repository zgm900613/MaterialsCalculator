<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>X-ray Diffraction Simulator (Powder + Detector View)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { margin-bottom: 0.3em; }
    .note { font-size: 0.85em; color: #666; }
    .row { margin-top: 8px; display: flex; align-items: center; }
    label { display: inline-block; width: 280px; }
    input, select { padding: 4px; }
    button { margin-top: 16px; padding: 8px 16px; font-size: 1em; }
    #charts { display: flex; flex-wrap: wrap; gap: 30px; margin-top: 20px; }
    .chart-container { flex: 1; min-width: 450px; }
    canvas { background: #fff; border: 1px solid #ddd; display: block; width: 100%; height: 450px; }
  </style>
</head>
<body>
<h1>X-ray Diffraction Simulator</h1>
<p class="note">
  Powder XRD profile (2θ stick plot with (hkl) labels)<br>
  and detector view (Debye-Scherrer rings on area detector).<br>
  q range fixed to 0–80 nm⁻¹.
</p>

<hr>
<h3>Beam & Detector</h3>
<div class="row">
  <label for="energy">X-ray Energy (keV):</label>
  <input id="energy" type="number" min="1" max="200" step="0.1" value="52" style="width:100px;">
</div>
<div class="row">
  <label for="detX">Detector size X (mm):</label>
  <input id="detX" type="number" min="1" step="1" value="432" style="width:100px;">
</div>
<div class="row">
  <label for="detY">Detector size Y (mm):</label>
  <input id="detY" type="number" min="1" step="1" value="432" style="width:100px;">
</div>
<div class="row">
  <label for="distance">Sample-to-detector distance (mm):</label>
  <input id="distance" type="number" min="1" step="1" value="1000" style="width:100px;">
</div>

<hr>
<h3>Crystal Structure & Lattice Parameters</h3>
<div class="row">
  <label for="structure">Crystal structure:</label>
  <select id="structure">
    <option value="FCC">FCC</option>
    <option value="BCC">BCC</option>
    <option value="HCP" selected>HCP</option>
  </select>
</div>
<div class="row">
  <label for="a">Lattice parameter a (nm):</label>
  <input id="a" type="number" min="0.01" step="0.001" value="0.321" style="width:120px;">
</div>
<div class="row" id="c-row">
  <label for="c">Lattice parameter c (nm, HCP only):</label>
  <input id="c" type="number" min="0.01" step="0.001" value="0.521" style="width:120px;">
</div>

<button onclick="calculateAndPlot()">Calculate & Plot</button>

<div id="charts">
  <div class="chart-container">
    <h3>XRD Profile (2θ vs Intensity)</h3>
    <div id="chart-toolbar">
      <button onclick="resetZoom('profile')">Home</button>
    </div>
    <canvas id="profile"></canvas>
  </div>
  <div class="chart-container">
    <h3>Detector View (Debye-Scherrer Rings)</h3>
    <div id="chart-toolbar">
      <button onclick="resetZoom('detector')">Home</button>
    </div>
    <canvas id="detector"></canvas>
  </div>
</div>

<p id="status" class="note" style="margin-top:20px; color:blue;">
  Adjust parameters and click "Calculate & Plot".
</p>

<script>
let chartProfile = null;
let chartDetector = null;

const hc = 1.23984193; // nm·keV

function wavelength_nm(energy_keV) {
  return hc / energy_keV;
}

function generateReflections(structure, a_nm, c_nm = null) {
  const reflections = [];
  const maxIndex = 8; // 减小到8以减少数量
  const a = a_nm;
  const c = c_nm || a * Math.sqrt(8/3);

  const uniqueD = new Set(); // 避免重复 d

  if (structure === "FCC" || structure === "BCC") {
    for (let h = 0; h <= maxIndex; h++) {
      for (let k = 0; k <= h; k++) {
        for (let l = 0; l <= k; l++) {
          if (h + k + l === 0) continue;
          let allowed = false;
          if (structure === "FCC") allowed = (h+k+l)%2===0 && h%2===k%2 && k%2===l%2;
          if (structure === "BCC") allowed = (h+k+l)%2===1;
          if (allowed) {
            const d = a / Math.sqrt(h*h + k*k + l*l);
            const dRounded = d.toFixed(5); // 避免浮点重复
            if (!uniqueD.has(dRounded)) {
              uniqueD.add(dRounded);
              reflections.push({h, k, l, d, hkl: `(${h}${k}${l})`});
            }
          }
        }
      }
    }
  } else if (structure === "HCP") {
    for (let h = 0; h <= maxIndex; h++) {
      for (let k = 0; k <= h; k++) {
        if (h===0 && k===0) continue;
        for (let l = 0; l <= maxIndex; l++) {
          const d_inv_sq = (4/3)*(h*h + h*k + k*k)/(a*a) + l*l/(c*c);
          if (d_inv_sq === 0) continue;
          const d = 1 / Math.sqrt(d_inv_sq);
          const dRounded = d.toFixed(5);
          if (!uniqueD.has(dRounded)) {
            uniqueD.add(dRounded);
            reflections.push({h, k, l, d, hkl: `(${h}${k}${l})`});
          }
        }
      }
    }
  }
  return reflections;
}

function calcIntensity(theta) {
  const mult = 12;
  const cos2theta = Math.cos(2*theta);
  const LP = (1 + cos2theta*cos2theta) / (Math.sin(theta)**2 * Math.cos(theta));
  return mult * LP;
}

function calculateAndPlot() {
  const status = document.getElementById("status");
  status.style.color = "blue";
  status.textContent = "Calculating...";

  try {
    const energy = parseFloat(document.getElementById("energy").value) || 52;
    const detX = parseFloat(document.getElementById("detX").value) || 432;
    const detY = parseFloat(document.getElementById("detY").value) || 432;
    const distance = parseFloat(document.getElementById("distance").value) || 1000;
    const structure = document.getElementById("structure").value;
    const a_nm = parseFloat(document.getElementById("a").value) || (structure==="HCP"?0.321:0.286);
    const c_nm = structure==="HCP" ? parseFloat(document.getElementById("c").value) || 0.521 : null;

    const lambda = wavelength_nm(energy);
    const q_max = 80;
    const twoTheta_max = 2 * Math.asin(q_max * lambda / (4*Math.PI)) * 180 / Math.PI;

    const refs = generateReflections(structure, a_nm, c_nm);

    const peaks = [];
    const rings = [];

    refs.forEach(ref => {
      const sinTheta = lambda / (2 * ref.d);
      if (sinTheta > 1 || sinTheta <= 0) return;
      const theta = Math.asin(sinTheta);
      const twoTheta = 2 * theta * 180 / Math.PI;
      const q = 4 * Math.PI * sinTheta / lambda;
      if (q > q_max) return;

      const intensity = calcIntensity(theta);
      peaks.push({twoTheta, intensity, hkl: ref.hkl});

      const r_mm = distance * Math.tan(2 * theta);
      rings.push({r_mm, hkl: ref.hkl});
    });

    peaks.sort((a,b) => a.twoTheta - b.twoTheta);
    const maxI = Math.max(...peaks.map(p => p.intensity), 1);
    peaks.forEach(p => p.relI = p.intensity / maxI * 100);

    plotXRDProfile(peaks, twoTheta_max);
    plotDetectorView(rings, detX, detY);

    status.style.color = "green";
    status.textContent = `Plotted ${peaks.length} reflections (2θ max ≈ ${twoTheta_max.toFixed(1)}°).`;
  } catch (err) {
    console.error(err);
    status.style.color = "red";
    status.textContent = "Error: " + err.message;
  }
}

function destroyChart(chartVar, canvasId) {
  if (chartVar) {
    chartVar.destroy();
    chartVar = null;
  }
  const canvas = document.getElementById(canvasId);
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.width = canvas.width; // 重设 canvas 属性
  }
}

function plotXRDProfile(peaks, twoTheta_max) {
  destroyChart(chartProfile, 'profile');
  const canvas = document.getElementById('profile');
  const ctx = canvas.getContext('2d');

  const stickData = [];
  peaks.forEach(p => {
    stickData.push({x: p.twoTheta, y: 0});
    stickData.push({x: p.twoTheta, y: p.relI});
    stickData.push(null);
  });

  setTimeout(() => {
    try {
      chartProfile = new Chart(ctx, {
        type: 'line',
        data: { datasets: [{ data: stickData, borderColor: '#0066ff', borderWidth: 2.5, pointRadius: 0 }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: '2θ (°)' }, min: 0, max: twoTheta_max * 1.05 },
            y: { title: { display: true, text: 'Relative Intensity (%)' }, min: 0, max: 110 }
          },
          plugins: {
            legend: { display: false },
            annotation: {
              annotations: peaks.map((p, i) => ({
                type: 'label',
                xValue: p.twoTheta,
                yValue: p.relI + 6,
                content: p.hkl,
                font: { size: 10 },
                color: '#000',
                backgroundColor: 'rgba(255,255,255,0.8)',
                padding: 2,
                rotation: 45  // 改为45°避免重叠
              }))
            },
            zoom: { pan: { enabled: true, mode: 'xy' }, zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: 'xy' } }
          }
        }
      });
    } catch (err) {
      console.error('Profile chart error:', err);
    }
  }, 0);
}

function plotDetectorView(rings, detX, detY) {
  destroyChart(chartDetector, 'detector');
  const canvas = document.getElementById('detector');
  const ctx = canvas.getContext('2d');

  const maxR = Math.max(...rings.map(r => r.r_mm).concat([detX/2, detY/2])) * 1.15;

  const annotations = {
    detectorBox: {
      type: 'box',
      xMin: -detX/2, xMax: detX/2,
      yMin: -detY/2, yMax: detY/2,
      borderColor: '#000',
      borderWidth: 3,
      backgroundColor: 'transparent'
    },
    center: {
      type: 'point',
      xValue: 0, yValue: 0,
      radius: 6,
      backgroundColor: '#000'
    }
  };

  rings.forEach((ring, i) => {
    annotations[`ring${i}`] = {
      type: 'ellipse',
      xMin: -ring.r_mm,
      xMax: ring.r_mm,
      yMin: -ring.r_mm,
      yMax: ring.r_mm,
      borderColor: 'rgba(255, 100, 100, 0.7)',
      borderWidth: 2,
      borderDash: [8, 4],
      backgroundColor: 'transparent'
    };
    annotations[`label${i}`] = {
      type: 'label',
      xValue: ring.r_mm * 1.02,  // 移到环外
      yValue: 0,
      content: ring.hkl,
      color: '#d00',
      font: { size: 11, weight: 'bold' },
      padding: 2
    };
  });

  setTimeout(() => {
    try {
      chartDetector = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            data: [{x: 0, y: 0}], // dummy
            pointRadius: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1,
          scales: {
            x: { display: false, min: -maxR, max: maxR },
            y: { display: false, min: -maxR, max: maxR }
          },
          plugins: {
            legend: { display: false },
            tooltip: { enabled: false },
            annotation: { annotations },
            zoom: { pan: { enabled: true, mode: 'xy' }, zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: 'xy' } }
          }
        }
      });
    } catch (err) {
      console.error('Detector chart error:', err);
    }
  }, 0);
}

function resetZoom(id) {
  if (id === 'profile' && chartProfile) chartProfile.resetZoom();
  if (id === 'detector' && chartDetector) chartDetector.resetZoom();
}

document.getElementById("structure").addEventListener("change", function() {
  const s = this.value;
  document.getElementById("c-row").style.display = s === "HCP" ? "flex" : "none";
  document.getElementById("a").value = s === "HCP" ? "0.321" : "0.286";
  if (s === "HCP") document.getElementById("c").value = "0.521";
});
</script>

<hr>
<p class="note" style="text-align:center;">
  © 2025 Gaoming Zhu. Synchrotron XRD Simulator (pure client-side).
</p>
</body>
</html>
