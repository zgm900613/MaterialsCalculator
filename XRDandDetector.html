<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>X-ray Diffraction Simulator (Powder + Detector View)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { margin-bottom: 0.3em; }
    .note { font-size: 0.85em; color: #666; }
    .row { margin-top: 8px; display: flex; align-items: center; }
    label { display: inline-block; width: 280px; }
    input, select { padding: 4px; }
    button { margin-top: 16px; padding: 8px 16px; font-size: 1em; }
    #charts { display: flex; flex-wrap: wrap; gap: 30px; margin-top: 20px; }
    .chart-container { flex: 1; min-width: 450px; position: relative; }
    #chart-toolbar { margin-top: 8px; }
    canvas { background: #fff; border: 1px solid #ddd; }
  </style>
</head>
<body>
<h1>X-ray Diffraction Simulator</h1>
<p class="note">
  Powder XRD profile (2θ stick plot with (hkl) labels)<br>
  and detector view (Debye-Scherrer rings on area detector).<br>
  Fixed q range: 0–80 nm⁻¹ → automatic 2θ range based on energy.
</p>

<hr>
<h3>Beam & Detector</h3>
<div class="row">
  <label for="energy">X-ray Energy (keV):</label>
  <input id="energy" type="number" min="1" max="200" step="0.1" value="52" style="width:100px;">
</div>
<div class="row">
  <label for="detX">Detector size X (mm):</label>
  <input id="detX" type="number" min="1" step="1" value="432" style="width:100px;">
</div>
<div class="row">
  <label for="detY">Detector size Y (mm):</label>
  <input id="detY" type="number" min="1" step="1" value="432" style="width:100px;">
</div>
<div class="row">
  <label for="distance">Sample-to-detector distance (mm):</label>
  <input id="distance" type="number" min="1" step="1" value="1000" style="width:100px;">
</div>

<hr>
<h3>Crystal Structure & Lattice Parameters</h3>
<div class="row">
  <label for="structure">Crystal structure:</label>
  <select id="structure">
    <option value="FCC">FCC</option>
    <option value="BCC">BCC</option>
    <option value="HCP" selected>HCP</option>
  </select>
</div>
<div class="row">
  <label for="a">Lattice parameter a (nm):</label>
  <input id="a" type="number" min="0.01" step="0.001" value="0.321" style="width:120px;">
</div>
<div class="row" id="c-row">
  <label for="c">Lattice parameter c (nm, HCP only):</label>
  <input id="c" type="number" min="0.01" step="0.001" value="0.521" style="width:120px;">
</div>

<button onclick="calculateAndPlot()">Calculate & Plot</button>

<div id="charts">
  <div class="chart-container">
    <h3>XRD Profile (2θ vs Intensity)</h3>
    <div id="chart-toolbar">
      <button onclick="resetZoom('profile')">Home</button>
    </div>
    <canvas id="profile"></canvas>
  </div>
  <div class="chart-container">
    <h3>Detector View (Debye-Scherrer Rings)</h3>
    <div id="chart-toolbar">
      <button onclick="resetZoom('detector')">Home</button>
    </div>
    <canvas id="detector"></canvas>
  </div>
</div>

<p id="status" class="note" style="margin-top:20px; color:blue;">
  Adjust parameters and click "Calculate & Plot".
</p>

<script>
let chartProfile = null;
let chartDetector = null;

const hc = 1.23984193; // nm·keV

function wavelength_nm(energy_keV) {
  return hc / energy_keV;
}

// Generate allowed (hkil) for HCP, (hkl) for cubic
function generateReflections(structure, a_nm, c_nm = null) {
  const reflections = [];
  const a = a_nm;
  const c = c_nm || a * Math.sqrt(8/3); // ideal c/a if not given
  const maxIndex = 10;

  if (structure === "FCC" || structure === "BCC") {
    for (let h = 0; h <= maxIndex; h++) {
      for (let k = 0; k <= maxIndex; k++) {
        for (let l = 0; l <= maxIndex; l++) {
          if (h === 0 && k === 0 && l === 0) continue;

          let allowed = false;
          if (structure === "FCC") {
            if ((h+k+l) % 2 === 0 && h%2 === k%2 && k%2 === l%2) allowed = true;
          } else if (structure === "BCC") {
            if ((h+k+l) % 2 === 1) allowed = true;
          }
          if (!allowed) continue;

          const d = a / Math.sqrt(h*h + k*k + l*l); // nm
          reflections.push({h, k, l, i:0, d, hkl: `(${h}${k}${l})`});
        }
      }
    }
  } else if (structure === "HCP") {
    // Standard hkil with i = -(h+k)
    for (let h = 0; h <= maxIndex; h++) {
      for (let k = 0; k <= maxIndex; k++) {
        if (h === 0 && k === 0) continue;
        for (let l = 0; l <= maxIndex; l++) {
          // Common extinction: -h+k+l = 3n for some, but we allow most typical ones
          const d_inv_sq = (4/3)*(h*h + h*k + k*k)/(a*a) + l*l/(c*c);
          const d = 1 / Math.sqrt(d_inv_sq); // nm
          const hkl = l === 0 ? `(${h}${k}0)` : `(${h}${k}${l})`;
          reflections.push({h, k, l, i: - (h+k), d, hkl});
        }
      }
    }
  }
  return reflections;
}

// Simplified multiplicity + Lorentz-polarization factor
function calcIntensity(ref, theta, structure) {
  let mult = 1;
  if (structure === "FCC" || structure === "BCC") {
    const perms = [];
    for (let sx=-1; sx<=1; sx+=2)
      for (let sy=-1; sy<=1; sy+=2)
        for (let sz=-1; sz<=1; sz+=2)
          if (!(sx*ref.h===0 && sy*ref.k===0 && sz*ref.l===0))
            perms.push(true);
    mult = perms.length / 8; // average
  } else if (structure === "HCP") {
    mult = 12; // rough
  }
  const LP = (1 + Math.cos(2*theta)**2) / (Math.sin(theta)**2 * Math.cos(theta));
  return mult * LP;
}

function calculateAndPlot() {
  const status = document.getElementById("status");
  status.style.color = "blue";
  status.textContent = "Calculating...";

  try {
    const energy = parseFloat(document.getElementById("energy").value) || 52;
    const detX = parseFloat(document.getElementById("detX").value) || 432;
    const detY = parseFloat(document.getElementById("detY").value) || 432;
    const distance = parseFloat(document.getElementById("distance").value) || 1000;
    const structure = document.getElementById("structure").value;
    const a_nm = parseFloat(document.getElementById("a").value) || (structure==="HCP"?0.321:0.286);
    const c_nm = structure==="HCP" ? parseFloat(document.getElementById("c").value) || 0.521 : null;

    const lambda = wavelength_nm(energy);
    const q_max = 80; // nm^{-1}
    const twoTheta_max = 2 * Math.asin(q_max * lambda / (4*Math.PI)) * 180 / Math.PI;

    const refs = generateReflections(structure, a_nm, c_nm);

    const peaks = [];
    const rings = [];

    refs.forEach(ref => {
      const sinTheta = lambda / (2 * ref.d);
      if (sinTheta > 1 || sinTheta <= 0) return;
      const theta = Math.asin(sinTheta);
      const twoTheta = 2 * theta * 180 / Math.PI;
      const q = 4 * Math.PI * sinTheta / lambda;
      if (q > q_max) return;

      const intensity = calcIntensity(ref, theta, structure);

      peaks.push({
        twoTheta,
        intensity,
        hkl: ref.hkl
      });

      const r_mm = distance * Math.tan(2 * theta);
      rings.push({r_mm, hkl: ref.hkl, intensity});
    });

    peaks.sort((a,b) => a.twoTheta - b.twoTheta);
    const maxI = Math.max(...peaks.map(p=>p.intensity), 1);
    peaks.forEach(p => p.relI = p.intensity / maxI * 100);

    plotXRDProfile(peaks, twoTheta_max);
    plotDetectorView(rings, detX, detY, Math.max(...rings.map(r=>r.r_mm), Math.max(detX,detY)/2) * 1.1);

    status.style.color = "green";
    status.textContent = `Plotted ${peaks.length} reflections (2θ max ≈ ${twoTheta_max.toFixed(1)}°).`;
  } catch (err) {
    console.error(err);
    status.style.color = "red";
    status.textContent = "Error: " + err;
  }
}

function plotXRDProfile(peaks, twoTheta_max) {
  const ctx = document.getElementById("profile").getContext("2d");
  if (chartProfile) chartProfile.destroy();

  // Stick plot: vertical lines from 0 to height
  const stickData = [];
  const labelData = [];
  peaks.forEach(p => {
    stickData.push({x: p.twoTheta, y: 0});
    stickData.push({x: p.twoTheta, y: p.relI});
    stickData.push(null); // break line
    labelData.push({x: p.twoTheta, y: p.relI + 3, hkl: p.hkl});
  });

  chartProfile = new Chart(ctx, {
    data: {
      datasets: [
        {
          type: 'line',
          data: stickData,
          borderColor: '#0066ff',
          borderWidth: 2,
          pointRadius: 0,
          tension: 0
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: '2θ (°)' },
          min: 0,
          max: twoTheta_max * 1.05
        },
        y: {
          title: { display: true, text: 'Relative Intensity (%)' },
          min: 0,
          max: 110
        }
      },
      plugins: {
        annotation: {
          annotations: labelData.map((p,i) => ({
            type: 'label',
            xValue: p.x,
            yValue: p.y,
            content: p.hkl,
            font: { size: 11 },
            color: '#000',
            backgroundColor: 'rgba(255,255,255,0.7)',
            padding: 2,
            rotation: 90
          }))
        },
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.parsed.y.toFixed(1)}% ${peaks[Math.floor(ctx.dataIndex/3)].hkl}`
          }
        },
        zoom: {
          pan: { enabled: true, mode: 'xy' },
          zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: 'xy' }
        }
      }
    }
  });
}

function plotDetectorView(rings, detX, detY, maxR) {
  const ctx = document.getElementById("detector").getContext("2d");
  if (chartDetector) chartDetector.destroy();

  const datasets = [];

  // Rings
  rings.forEach(ring => {
    datasets.push({
      type: 'scatter',
      data: [{x:0, y:0}],
      radius: ring.r_mm * (ctx.canvas.width / (2 * maxR)), // scale to canvas
      borderColor: 'rgba(255, 100, 100, 0.7)',
      borderDash: [8, 4],
      borderWidth: 2,
      pointStyle: 'circle',
      backgroundColor: 'transparent'
    });
    // Label
    datasets.push({
      type: 'scatter',
      data: [{x: ring.r_mm * 0.85, y: 0}],
      pointBackgroundColor: 'transparent',
      datalabels: {
        display: true,
        color: '#d00',
        font: { size: 10 },
        align: 'end',
        offset: 4,
        labels: { title: { text: ring.hkl } }
      }
    });
  });

  chartDetector = new Chart(ctx, {
    data: { datasets },
    options: {
      responsive: true,
      aspectRatio: 1,
      scales: {
        x: { display: false, min: -maxR, max: maxR },
        y: { display: false, min: -maxR, max: maxR }
      },
      plugins: {
        legend: { display: false },
        tooltip: { enabled: false },
        annotation: {
          annotations: {
            box: {
              type: 'box',
              xMin: -detX/2,
              xMax: detX/2,
              yMin: -detY/2,
              yMax: detY/2,
              borderColor: '#000',
              borderWidth: 3,
              backgroundColor: 'transparent'
            },
            center: {
              type: 'point',
              xValue: 0,
              yValue: 0,
              radius: 5,
              backgroundColor: '#000'
            }
          }
        },
        zoom: {
          pan: { enabled: true, mode: 'xy' },
          zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: 'xy' }
        }
      }
    }
  });
}

function resetZoom(id) {
  if (id === 'profile' && chartProfile) chartProfile.resetZoom();
  if (id === 'detector' && chartDetector) chartDetector.resetZoom();
}

// Switch structure
document.getElementById("structure").addEventListener("change", function() {
  const s = this.value;
  document.getElementById("c-row").style.display = s === "HCP" ? "flex" : "none";
  if (s !== "HCP") {
    document.getElementById("a").value = "0.286";
  } else {
    document.getElementById("a").value = "0.321";
    document.getElementById("c").value = "0.521";
  }
});
</script>

<hr>
<p class="note" style="text-align:center;">
  © 2025 Gaoming Zhu. Synchrotron XRD Powder & Detector Simulator (client-side only).
</p>
</body>
</html>
