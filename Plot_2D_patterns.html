<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Detector Diffraction Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Plotly for 2D heatmap + zoom/pan -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <!-- UTIF.js for TIFF decoding -->
  <script src="https://unpkg.com/utif@2.0.1/UTIF.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { margin-bottom: 0.3em; }
    .note { font-size: 0.85em; color: #666; }

    #drop-zone {
      border: 2px dashed #999;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #666;
      margin-top: 10px;
    }
    #drop-zone.dragover {
      border-color: #007bff;
      color: #007bff;
      background-color: #f0f8ff;
    }
    #file-input {
      margin-top: 10px;
    }

    .row { margin-top: 6px; }
    label { display: inline-block; width: 210px; margin-top: 4px; }
    input, select { padding: 4px; }
    button { margin-top: 10px; padding: 6px 12px; }

    #plot-container { margin-top: 20px; text-align:center; }
    /* 正方形画布：基于视窗最小尺寸 */
    #plot {
      width: 80vmin;
      height: 80vmin;
      margin: 0 auto;
    }
  </style>
</head>

<body>
<h1>2D Detector Diffraction Viewer</h1>
<p class="note">
  Upload a 2D detector diffraction image (CBF with X-CBF_BYTE_OFFSET compression, or TIFF).<br>
  The image will be shown as a 2D heatmap with optional log intensity, colorbar, zoom and geometry transforms.
</p>

<!-- 文件选择 -->
<p>
  <input type="file" id="file-input" />
</p>

<!-- 拖拽区域 -->
<div id="drop-zone">
  Drag & drop a CBF or TIFF/TIF file here,<br>
  or use the file selection above.
</div>

<p id="status" class="note" style="margin-top:10px; color:blue;">
  No file loaded yet.
</p>

<hr>

<h3>Display options</h3>

<div class="row">
  <label for="colorscale">Color scale:</label>
  <select id="colorscale">
    <option value="Greys">Greys</option>
    <option value="Greys_r">Greys (reversed)</option>
    <option value="Viridis" selected>Viridis</option>
    <option value="Viridis_r">Viridis (reversed)</option>
    <option value="Plasma">Plasma</option>
    <option value="Plasma_r">Plasma (reversed)</option>
    <option value="Cividis">Cividis</option>
    <option value="Cividis_r">Cividis (reversed)</option>
    <option value="Hot">Hot</option>
    <option value="Hot_r">Hot (reversed)</option>
    <option value="Rainbow">Rainbow</option>
    <option value="Rainbow_r">Rainbow (reversed)</option>
    <option value="gray_clip">gray_clip-like (clip above max to red)</option>
  </select>
</div>

<div class="row">
  <label></label>
  <label style="width:auto;">
    <input type="checkbox" id="showColorbar" checked> Show colorbar
  </label>
  <label style="width:auto; margin-left:16px;">
    <input type="checkbox" id="logIntensity"> Log color scale (log10)
  </label>
</div>

<div class="row">
  <label for="geomMode">Geometry transform:</label>
  <select id="geomMode">
    <option value="orig">Original</option>
    <option value="rot90">Rotate 90° CCW</option>
    <option value="rot180">Rotate 180°</option>
    <option value="rot270">Rotate 270° CCW</option>
    <option value="flipX">Flip horizontally</option>
    <option value="flipY">Flip vertically</option>
    <option value="flipDiag">Flip main diagonal</option>
    <option value="flipAntiDiag">Flip anti-diagonal</option>
  </select>
</div>

<h4>Axis & Intensity limits (optional)</h4>

<div class="row">
  <label for="xMin">X min (pixel):</label>
  <input id="xMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="xMax">X max (pixel):</label>
  <input id="xMax" type="number" style="width:120px;">
</div>

<div class="row">
  <label for="yMin">Y min (pixel):</label>
  <input id="yMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="yMax">Y max (pixel):</label>
  <input id="yMax" type="number" style="width:120px;">
</div>

<div class="row">
  <label for="zMin">Intensity min (optional, linear):</label>
  <input id="zMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="zMax">Intensity max (optional, linear):</label>
  <input id="zMax" type="number" style="width:120px;" value="500">
</div>

<button onclick="plotImage()">Plot / Update</button>
<button onclick="resetView()">Home</button>

<hr>

<div id="plot-container">
  <div id="plot"></div>
</div>

<script>
let currentImage = null; // {width, height, z: 2D array of numbers}

// ---- 文件读取：选择 ----
document.getElementById("file-input").addEventListener("change", function (e) {
  const file = e.target.files[0];
  if (file) {
    readFile(file);
  }
});

// ---- 文件读取：拖拽 ----
const dropZone = document.getElementById("drop-zone");
dropZone.addEventListener("dragover", function (e) {
  e.preventDefault();
  e.stopPropagation();
  dropZone.classList.add("dragover");
});
dropZone.addEventListener("dragleave", function (e) {
  e.preventDefault();
  e.stopPropagation();
  dropZone.classList.remove("dragover");
});
dropZone.addEventListener("drop", function (e) {
  e.preventDefault();
  e.stopPropagation();
  dropZone.classList.remove("dragover");
  const file = e.dataTransfer.files[0];
  if (file) {
    readFile(file);
  }
});

// ---- 读取文件并根据格式解码 ----
function readFile(file) {
  const status = document.getElementById("status");
  status.style.color = "blue";
  status.textContent = "Reading file: " + file.name + " …";

  const reader = new FileReader();
  reader.onload = function (e) {
    const arrayBuffer = e.target.result;
    const ext = (file.name || "").toLowerCase();

    try {
      if (ext.endsWith(".cbf")) {
        const bytes = new Uint8Array(arrayBuffer);
        currentImage = decodeCBF_byteOffset(bytes);
      } else if (ext.endsWith(".tif") || ext.endsWith(".tiff")) {
        currentImage = decodeTIFF(arrayBuffer);
      } else {
        status.style.color = "red";
        status.textContent = "Unsupported file type. Please use CBF or TIFF/TIF.";
        currentImage = null;
        return;
      }

      if (!currentImage || !currentImage.z) {
        throw new Error("Decoded image is empty.");
      }

      const { width, height } = currentImage;
      status.style.color = "green";
      status.textContent = `Image loaded: ${file.name} (${width} × ${height}). Adjust options and press "Plot / Update".`;

      // 不再清空默认值（保持 0 / 500），直接按当前输入画图
      plotImage();
    } catch (err) {
      console.error(err);
      status.style.color = "red";
      status.textContent = "Error decoding file: " + err;
      currentImage = null;
    }
  };
  reader.onerror = function () {
    status.style.color = "red";
    status.textContent = "Error reading file.";
  };
  reader.readAsArrayBuffer(file);
}

// ---- 解码 CBF (X-CBF_BYTE_OFFSET, unsigned 16-bit) ----
function decodeCBF_byteOffset(bytes) {
  const magic = [0x0c, 0x1a, 0x04, 0xd5];
  let idx = -1;
  for (let i = 0; i < bytes.length - 4; i++) {
    if (
      bytes[i] === magic[0] &&
      bytes[i + 1] === magic[1] &&
      bytes[i + 2] === magic[2] &&
      bytes[i + 3] === magic[3]
    ) {
      idx = i;
      break;
    }
  }
  if (idx < 0) {
    throw new Error("CBF binary marker 0C 1A 04 D5 not found.");
  }

  const headerBytes = bytes.slice(0, idx);
  const headerText = new TextDecoder("latin1").decode(headerBytes);

  function headerInt(name) {
    const re = new RegExp(name + "\\s*:\\s*([0-9]+)");
    const m = headerText.match(re);
    if (!m) {
      throw new Error("Missing header: " + name);
    }
    return parseInt(m[1], 10);
  }

  const sizeBytes = headerInt("X-Binary-Size");
  const nElem = headerInt("X-Binary-Number-of-Elements");
  const fast = headerInt("X-Binary-Size-Fastest-Dimension");
  const slow = headerInt("X-Binary-Size-Second-Dimension");

  const start = idx + 4;
  if (start + sizeBytes > bytes.length) {
    throw new Error("CBF binary size exceeds file length.");
  }

  const compBytes = bytes.slice(start, start + sizeBytes);
  const flat = decompressCBFByteOffset(compBytes, nElem);

  if (flat.length !== nElem) {
    console.warn("Decompressed pixel count", flat.length, "!= header", nElem);
  }

  const width = fast;
  const height = slow;

  const z = new Array(height);
  let p = 0;
  for (let y = 0; y < height; y++) {
    const row = new Array(width);
    for (let x = 0; x < width; x++) {
      row[x] = flat[p++];
    }
    z[y] = row;
  }

  return { width, height, z };
}

function decompressCBFByteOffset(bytes, nPixels) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const out = new Uint32Array(nPixels);
  let base = 0;
  let pos = 0;
  let outPos = 0;
  const n = bytes.length;

  while (pos < n && outPos < nPixels) {
    let delta = view.getInt8(pos);
    pos += 1;

    if (delta >= -127 && delta <= 127) {
      base = (base + delta) | 0;
      out[outPos++] = base >>> 0;
      continue;
    }

    if (pos + 2 > n) break;
    let delta16 = view.getInt16(pos, true);
    pos += 2;
    if (delta16 >= -32767 && delta16 <= 32767) {
      base = (base + delta16) | 0;
      out[outPos++] = base >>> 0;
      continue;
    }

    if (pos + 4 > n) break;
    let delta32 = view.getInt32(pos, true);
    pos += 4;
    base = base + delta32;
    out[outPos++] = base >>> 0;
  }

  return out;
}

// ---- 解码 TIFF（通过 UTIF.js，转为灰度强度） ----
function decodeTIFF(arrayBuffer) {
  const ifds = UTIF.decode(arrayBuffer);
  if (!ifds || ifds.length === 0) {
    throw new Error("No IFDs found in TIFF.");
  }
  UTIF.decodeImage(arrayBuffer, ifds[0]);
  const rgba = UTIF.toRGBA8(ifds[0]);
  const width = ifds[0].width;
  const height = ifds[0].height;

  const z = new Array(height);
  let p = 0;
  for (let y = 0; y < height; y++) {
    const row = new Array(width);
    for (let x = 0; x < width; x++) {
      const r = rgba[p];
      const g = rgba[p + 1];
      const b = rgba[p + 2];
      const val = 0.299 * r + 0.587 * g + 0.114 * b;
      row[x] = val;
      p += 4;
    }
    z[y] = row;
  }
  return { width, height, z };
}

// ---- 8 种几何变换（D4） ----
function applyGeometry(z, mode) {
  const h = z.length;
  const w = z[0].length;

  function clone2D(a) {
    return a.map(row => row.slice());
  }

  switch (mode) {
    case "flipX": { // 左右翻转
      const out = new Array(h);
      for (let y = 0; y < h; y++) {
        const row = new Array(w);
        for (let x = 0; x < w; x++) {
          row[x] = z[y][w - 1 - x];
        }
        out[y] = row;
      }
      return { z: out, width: w, height: h };
    }

    case "flipY": { // 上下翻转
      const out = new Array(h);
      for (let y = 0; y < h; y++) {
        out[y] = z[h - 1 - y].slice();
      }
      return { z: out, width: w, height: h };
    }

    case "rot180": { // 180°
      const out = new Array(h);
      for (let y = 0; y < h; y++) {
        const row = new Array(w);
        for (let x = 0; x < w; x++) {
          row[x] = z[h - 1 - y][w - 1 - x];
        }
        out[y] = row;
      }
      return { z: out, width: w, height: h };
    }

    case "rot90": { // 90° CCW
      const H2 = w;
      const W2 = h;
      const out = new Array(H2);
      for (let y2 = 0; y2 < H2; y2++) {
        const row = new Array(W2);
        for (let x2 = 0; x2 < W2; x2++) {
          const srcX = x2;
          const srcY = h - 1 - y2;
          row[x2] = z[srcY][srcX];
        }
        out[y2] = row;
      }
      return { z: out, width: W2, height: H2 };
    }

    case "rot270": { // 270° CCW (90° CW)
      const H2 = w;
      const W2 = h;
      const out = new Array(H2);
      for (let y2 = 0; y2 < H2; y2++) {
        const row = new Array(W2);
        for (let x2 = 0; x2 < W2; x2++) {
          const srcX = w - 1 - x2;
          const srcY = y2;
          row[x2] = z[srcY][srcX];
        }
        out[y2] = row;
      }
      return { z: out, width: W2, height: H2 };
    }

    case "flipDiag": { // 主对角线翻转
      const H2 = w;
      const W2 = h;
      const out = new Array(H2);
      for (let y2 = 0; y2 < H2; y2++) {
        const row = new Array(W2);
        for (let x2 = 0; x2 < W2; x2++) {
          const srcX = y2;
          const srcY = x2;
          row[x2] = z[srcY][srcX];
        }
        out[y2] = row;
      }
      return { z: out, width: W2, height: H2 };
    }

    case "flipAntiDiag": { // 反对角线翻转
      const H2 = w;
      const W2 = h;
      const out = new Array(H2);
      for (let y2 = 0; y2 < H2; y2++) {
        const row = new Array(W2);
        for (let x2 = 0; x2 < W2; x2++) {
          const srcX = w - 1 - y2;
          const srcY = h - 1 - x2;
          row[x2] = z[srcY][srcX];
        }
        out[y2] = row;
      }
      return { z: out, width: W2, height: H2 };
    }

    case "orig":
    default:
      return { z: clone2D(z), width: w, height: h };
  }
}

// ---- colormap 名称解析 ----
function getColorScaleConfig(name) {
  if (name.endsWith("_r")) {
    return {
      scale: name.slice(0, -2),
      reverse: true
    };
  }
  return { scale: name, reverse: false };
}

// ---- 绘图 ----
function plotImage() {
  const status = document.getElementById("status");
  if (!currentImage || !currentImage.z) {
    status.style.color = "red";
    status.textContent = "No image loaded.";
    return;
  }

  const colorOpt = document.getElementById("colorscale").value;
  let baseScale, reverse;
  if (colorOpt === "gray_clip") {
    baseScale = "Greys"; // 用 Greys 做基础
    reverse = false;
  } else {
    ({ scale: baseScale, reverse } = getColorScaleConfig(colorOpt));
  }

  const showColorbar = document.getElementById("showColorbar").checked;
  const logIntensity = document.getElementById("logIntensity").checked;
  const geomMode = document.getElementById("geomMode").value;

  const xMinUser = document.getElementById("xMin").value;
  const xMaxUser = document.getElementById("xMax").value;
  const yMinUser = document.getElementById("yMin").value;
  const yMaxUser = document.getElementById("yMax").value;
  const zMinUser = document.getElementById("zMin").value;
  const zMaxUser = document.getElementById("zMax").value;

  // 几何变换
  const geom = applyGeometry(currentImage.z, geomMode);
  const zGeom = geom.z;
  const width = geom.width;
  const height = geom.height;

  // 统计线性强度的 min/max
  let linMin = Infinity;
  let linMax = -Infinity;
  for (let y = 0; y < height; y++) {
    const row = zGeom[y];
    for (let x = 0; x < width; x++) {
      const v = row[x];
      if (v < linMin) linMin = v;
      if (v > linMax) linMax = v;
    }
  }

  if (!isFinite(linMin) || !isFinite(linMax)) {
    status.style.color = "red";
    status.textContent = "No valid intensity data.";
    return;
  }

  // Intensity 范围（线性空间）
  let zMinLinear = linMin;
  let zMaxLinear = linMax;
  if (zMinUser !== "") zMinLinear = parseFloat(zMinUser);
  if (zMaxUser !== "") zMaxLinear = parseFloat(zMaxUser);

  if (logIntensity && zMinLinear <= 0) {
    // log 模式需要正数
    zMinLinear = Math.max(zMinLinear, 1e-12);
  }

  // 构造绘制用的 zPlot + colorbar 设置
  let zPlot = new Array(height);
  let plotZmin, plotZmax;
  let colorbarConfig = {};

  if (!logIntensity) {
    // ===== 线性颜色映射 =====
    if (colorOpt === "gray_clip") {
      // clip 逻辑：<= zMaxLinear 用灰度，> zMaxLinear 用红色
      const delta = (zMaxLinear - zMinLinear) || 1;
      const zMaxPlot = zMaxLinear + delta; // 上方预留一段红色区间
      plotZmin = zMinLinear;
      plotZmax = zMaxPlot;

      for (let y = 0; y < height; y++) {
        const row = zGeom[y];
        const outRow = new Array(width);
        for (let x = 0; x < width; x++) {
          const v = row[x];
          if (v <= zMinLinear) {
            outRow[x] = zMinLinear;
          } else if (v <= zMaxLinear) {
            outRow[x] = v;
          } else {
            outRow[x] = zMaxPlot; // 超出部分映射到红色区间
          }
        }
        zPlot[y] = outRow;
      }

      const clipPos = (zMaxLinear - zMinLinear) / (plotZmax - zMinLinear); // 大约 0.5
      const cs = [
        [0.0, "rgb(0,0,0)"],
        [clipPos * 0.999, "rgb(255,255,255)"],
        [clipPos, "rgb(255,255,255)"],
        [clipPos + 1e-6, "rgb(255,0,0)"],
        [1.0, "rgb(255,0,0)"]
      ];

      colorbarConfig = {
        title: "Intensity (linear)",
      };

      drawPlot(zPlot, cs, false, showColorbar,
               plotZmin, plotZmax,
               colorbarConfig,
               width, height,
               xMinUser, xMaxUser, yMinUser, yMaxUser,
               status, baseScale, reverse, logIntensity, colorOpt);
      return;

    } else {
      // 普通线性 colormap
      plotZmin = zMinLinear;
      plotZmax = zMaxLinear;

      for (let y = 0; y < height; y++) {
        const row = zGeom[y];
        const outRow = new Array(width);
        for (let x = 0; x < width; x++) {
          outRow[x] = row[x];
        }
        zPlot[y] = outRow;
      }

      colorbarConfig = {
        title: "Intensity (linear)"
      };
    }

  } else {
    // ===== log10 颜色映射（colorbar 仍显示线性强度） =====
    let posMin = Infinity;
    let posMax = -Infinity;
    for (let y = 0; y < height; y++) {
      const row = zGeom[y];
      for (let x = 0; x < width; x++) {
        const v = row[x];
        if (v > 0) {
          if (v < posMin) posMin = v;
          if (v > posMax) posMax = v;
        }
      }
    }
    if (!isFinite(posMin) || !isFinite(posMax)) {
      status.style.color = "red";
      status.textContent = "No positive intensity values for log scale.";
      return;
    }

    const zMinPos = Math.max(zMinLinear, posMin);
    const zMaxPos = Math.min(zMaxLinear, posMax);
    if (!(zMaxPos > zMinPos)) {
      status.style.color = "red";
      status.textContent = "Invalid intensity range for log scale.";
      return;
    }

    const logMin = Math.log10(zMinPos);
    const logMax = Math.log10(zMaxPos);

    plotZmin = logMin;
    plotZmax = logMax;

    for (let y = 0; y < height; y++) {
      const row = zGeom[y];
      const outRow = new Array(width);
      for (let x = 0; x < width; x++) {
        const v = row[x];
        if (v > 0) {
          outRow[x] = Math.log10(v);
        } else {
          outRow[x] = null;
        }
      }
      zPlot[y] = outRow;
    }

    const decadeMin = Math.ceil(logMin);
    const decadeMax = Math.floor(logMax);
    let tickVals = [];
    let tickText = [];
    if (decadeMax >= decadeMin) {
      for (let p = decadeMin; p <= decadeMax; p++) {
        tickVals.push(p);
        const val = Math.pow(10, p);
        tickText.push(val.toExponential(1));
      }
    } else {
      tickVals = [logMin, logMax];
      tickText = [zMinPos.toExponential(2), zMaxPos.toExponential(2)];
    }

    colorbarConfig = {
      title: "Intensity (log scale)",
      tickmode: "array",
      tickvals: tickVals,
      ticktext: tickText
    };
  }

  // 坐标轴范围
  let xMin = 0;
  let xMax = width - 1;
  let yMin = 0;
  let yMax = height - 1;

  if (xMinUser !== "") xMin = parseFloat(xMinUser);
  if (xMaxUser !== "") xMax = parseFloat(xMaxUser);
  if (yMinUser !== "") yMin = parseFloat(yMinUser);
  if (yMaxUser !== "") yMax = parseFloat(yMaxUser);

  const csToUse = baseScale; // 字符串 colorscale

  drawPlot(zPlot, csToUse, reverse, showColorbar,
           plotZmin, plotZmax,
           colorbarConfig,
           width, height,
           xMin, xMax, yMin, yMax,
           status, baseScale, reverse, logIntensity, colorOpt);
}

// 真正调用 Plotly.newPlot 的部分抽出来复用
function drawPlot(
  zPlot, colorscale, reversescale, showColorbar,
  zmin, zmax, colorbarConfig,
  width, height,
  xMin, xMax, yMin, yMax,
  status, baseScaleName, reverseFlag, logIntensity, colorOpt
) {
  const trace = {
    z: zPlot,
    type: "heatmap",
    colorscale: colorscale,
    reversescale: reversescale,
    showscale: showColorbar,
    zmin: zmin,
    zmax: zmax,
    colorbar: colorbarConfig
  };

  const layout = {
    margin: { l: 60, r: 10, t: 30, b: 60 },
    xaxis: {
      title: "X (pixels)",
      range: [xMin, xMax]
    },
    yaxis: {
      title: "Y (pixels)",
      range: [yMin, yMax],
      scaleanchor: "x"  // 保持比例 1:1
    },
    dragmode: "zoom"
  };

  Plotly.newPlot("plot", [trace], layout, {
    responsive: true,
    displaylogo: false
  }).then(gd => {
    status.style.color = "green";
    let csName = (colorOpt === "gray_clip") ? "gray_clip-like" : baseScaleName;
    status.textContent =
      `Plotted image (${width} × ${height}) with ${csName}` +
      (reverseFlag && colorOpt !== "gray_clip" ? " (reversed)" : "") +
      (logIntensity ? " [log color scale]." : ".");
  });
}

// ---- Home: 恢复视图 ----
function resetView() {
  const plotDiv = document.getElementById("plot");
  if (!plotDiv || !plotDiv.data) return;

  Plotly.relayout(plotDiv, {
    "xaxis.autorange": true,
    "yaxis.autorange": true
  });
}
</script>

<hr>
<p class="note" style="text-align:center;">
  © 2025 Gaoming Zhu.
</p>

</body>
</html>
