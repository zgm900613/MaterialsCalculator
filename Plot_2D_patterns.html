<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Detector Diffraction Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Plotly for 2D heatmap + zoom/pan -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- IMPORTANT: load a UTIF build that actually exposes decode/decodeImage -->
  <!-- unpkg usually serves the real package root file -->
  <script src="https://unpkg.com/utif@2.0.1/UTIF.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { margin-bottom: 0.3em; }
    .note { font-size: 0.85em; color: #666; }

    #drop-zone {
      border: 2px dashed #999;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #666;
      margin-top: 10px;
    }
    #drop-zone.dragover {
      border-color: #007bff;
      color: #007bff;
      background-color: #f0f8ff;
    }

    .row { margin-top: 6px; }
    label { display: inline-block; width: 240px; margin-top: 4px; }
    input, select { padding: 4px; }
    button { margin-top: 10px; padding: 6px 12px; }

    #plot-container { margin-top: 20px; text-align:center; }
    /* square viewer */
    #plot {
      width: 80vmin;
      height: 80vmin;
      margin: 0 auto;
    }
  </style>
</head>

<body>
<h1>2D Detector Diffraction Viewer</h1>
<p class="note">
  Upload a 2D detector image: CBF (X-CBF_BYTE_OFFSET), TIFF/TIF (8/16-bit), or normal images (PNG/JPG/etc.).<br>
  Zoom: drag to zoom. Home: reset view.
</p>

<p><input type="file" id="file-input" /></p>

<div id="drop-zone">
  Drag & drop a file here (CBF / TIF / TIFF / PNG / JPG / ...),
  <br>or use the file selection above.
</div>

<p id="status" class="note" style="margin-top:10px; color:blue;">No file loaded yet.</p>

<hr>

<h3>Display options</h3>

<div class="row">
  <label for="colorscale">Color scale:</label>
  <select id="colorscale">
    <option value="Greys">Greys</option>
    <option value="Greys_r">Greys (reversed)</option>
    <option value="Viridis" selected>Viridis</option>
    <option value="Viridis_r">Viridis (reversed)</option>
    <option value="Plasma">Plasma</option>
    <option value="Plasma_r">Plasma (reversed)</option>
    <option value="Cividis">Cividis</option>
    <option value="Cividis_r">Cividis (reversed)</option>
    <option value="Turbo">Turbo</option>
    <option value="Turbo_r">Turbo (reversed)</option>
    <option value="Hot">Hot</option>
    <option value="Hot_r">Hot (reversed)</option>
    <option value="gray_clip">gray_clip-like (clip above max to red)</option>
  </select>
</div>

<div class="row">
  <label></label>
  <label style="width:auto;">
    <input type="checkbox" id="showColorbar" checked> Show colorbar
  </label>
  <label style="width:auto; margin-left:16px;">
    <input type="checkbox" id="logIntensity"> Log color scale (log10)
  </label>
</div>

<div class="row">
  <label for="geomMode">Transformation (LaVue-like):</label>
  <select id="geomMode">
    <option value="none">none</option>
    <option value="flipUD">flip (up-down)</option>
    <option value="flipLR">flip (left-right)</option>
    <option value="transpose">transpose</option>
    <option value="rot90cw">rot90 (clockwise)</option>
    <option value="rot180">rot180</option>
    <option value="rot270cw">rot270 (clockwise)</option>
    <option value="rot180_transpose">rot180 + transpose</option>
  </select>
</div>

<h4>Axis & Intensity limits (optional)</h4>

<div class="row">
  <label for="xMin">X min (pixel):</label>
  <input id="xMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="xMax">X max (pixel):</label>
  <input id="xMax" type="number" style="width:120px;">
</div>

<div class="row">
  <label for="yMin">Y min (pixel):</label>
  <input id="yMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="yMax">Y max (pixel):</label>
  <input id="yMax" type="number" style="width:120px;">
</div>

<div class="row">
  <label for="zMin">Intensity min (optional, linear):</label>
  <input id="zMin" type="number" style="width:120px;" value="0">
</div>
<div class="row">
  <label for="zMax">Intensity max (optional, linear):</label>
  <input id="zMax" type="number" style="width:120px;" value="500">
</div>

<button onclick="plotImage()">Plot / Update</button>
<button onclick="resetView()">Home</button>

<hr>

<div id="plot-container">
  <div id="plot"></div>
</div>

<script>
let currentImage = null; // {width, height, z: number[][]}

function setStatus(text, color="blue") {
  const el = document.getElementById("status");
  el.style.color = color;
  el.textContent = text;
}
function extLower(name) { return (name || "").toLowerCase(); }

// ---------- file input / drag drop ----------
document.getElementById("file-input").addEventListener("change", async (e) => {
  const file = e.target.files && e.target.files[0];
  if (file) await readFile(file);
});

const dropZone = document.getElementById("drop-zone");
dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener("dragleave", (e) => { e.preventDefault(); dropZone.classList.remove("dragover"); });
dropZone.addEventListener("drop", async (e) => {
  e.preventDefault(); dropZone.classList.remove("dragover");
  const file = e.dataTransfer.files && e.dataTransfer.files[0];
  if (file) await readFile(file);
});

async function readFile(file) {
  setStatus(`Reading: ${file.name} ...`, "blue");
  const ext = extLower(file.name);

  try {
    // normal raster images (browser decode)
    if (ext.endsWith(".png") || ext.endsWith(".jpg") || ext.endsWith(".jpeg") ||
        ext.endsWith(".gif") || ext.endsWith(".bmp") || ext.endsWith(".webp")) {
      currentImage = await decodeRasterImage(file);
      setStatus(`Loaded: ${file.name} (${currentImage.width} × ${currentImage.height}).`, "green");
      plotImage();
      return;
    }

    const buf = await file.arrayBuffer();

    if (ext.endsWith(".cbf")) {
      currentImage = decodeCBF_byteOffset(new Uint8Array(buf));
    } else if (ext.endsWith(".tif") || ext.endsWith(".tiff")) {
      currentImage = decodeTIFF_preserveBitDepth(buf);
    } else {
      throw new Error("Unsupported file type.");
    }

    setStatus(`Loaded: ${file.name} (${currentImage.width} × ${currentImage.height}).`, "green");
    plotImage();
  } catch (err) {
    console.error(err);
    currentImage = null;
    setStatus("Error decoding file: " + (err?.message || err), "red");
  }
}

// ---------- PNG/JPG decode ----------
function decodeRasterImage(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const w = img.naturalWidth, h = img.naturalHeight;
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      const data = ctx.getImageData(0, 0, w, h).data;

      const z = new Array(h);
      let p = 0;
      for (let y = 0; y < h; y++) {
        const row = new Array(w);
        for (let x = 0; x < w; x++) {
          const r = data[p], g = data[p+1], b = data[p+2];
          row[x] = 0.299*r + 0.587*g + 0.114*b;
          p += 4;
        }
        z[y] = row;
      }
      URL.revokeObjectURL(img.src);
      resolve({ width: w, height: h, z });
    };
    img.onerror = () => reject(new Error("Failed to load raster image."));
    img.src = URL.createObjectURL(file);
  });
}

// ---------- CBF (X-CBF_BYTE_OFFSET) ----------
function decodeCBF_byteOffset(bytes) {
  const magic = [0x0c, 0x1a, 0x04, 0xd5];
  let idx = -1;
  for (let i = 0; i < bytes.length - 4; i++) {
    if (bytes[i]===magic[0] && bytes[i+1]===magic[1] && bytes[i+2]===magic[2] && bytes[i+3]===magic[3]) {
      idx = i; break;
    }
  }
  if (idx < 0) throw new Error("CBF marker 0C 1A 04 D5 not found.");

  const headerText = new TextDecoder("latin1").decode(bytes.slice(0, idx));
  const headerInt = (name) => {
    const m = headerText.match(new RegExp(name + "\\s*:\\s*([0-9]+)"));
    if (!m) throw new Error("Missing header: " + name);
    return parseInt(m[1], 10);
  };

  const sizeBytes = headerInt("X-Binary-Size");
  const nElem = headerInt("X-Binary-Number-of-Elements");
  const fast = headerInt("X-Binary-Size-Fastest-Dimension");
  const slow = headerInt("X-Binary-Size-Second-Dimension");

  const start = idx + 4;
  if (start + sizeBytes > bytes.length) throw new Error("CBF binary exceeds file length.");

  const flat = decompressCBFByteOffset(bytes.slice(start, start + sizeBytes), nElem);

  const width = fast, height = slow;
  const z = new Array(height);
  let p = 0;
  for (let y = 0; y < height; y++) {
    const row = new Array(width);
    for (let x = 0; x < width; x++) row[x] = flat[p++];
    z[y] = row;
  }
  return { width, height, z };
}

function decompressCBFByteOffset(bytes, nPixels) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const out = new Int32Array(nPixels);
  let base = 0, pos = 0, outPos = 0;

  while (pos < bytes.length && outPos < nPixels) {
    let d8 = view.getInt8(pos); pos += 1;
    if (d8 >= -127 && d8 <= 127) { base = (base + d8)|0; out[outPos++] = base; continue; }

    if (pos + 2 > bytes.length) break;
    let d16 = view.getInt16(pos, true); pos += 2;
    if (d16 >= -32767 && d16 <= 32767) { base = (base + d16)|0; out[outPos++] = base; continue; }

    if (pos + 4 > bytes.length) break;
    let d32 = view.getInt32(pos, true); pos += 4;
    base = (base + d32)|0; out[outPos++] = base;
  }
  return out;
}

// ---------- TIFF (preserve 8/16-bit grayscale if possible) ----------
function decodeTIFF_preserveBitDepth(arrayBuffer) {
  if (typeof UTIF === "undefined") {
    throw new Error("UTIF is not defined. UTIF.js was not loaded.");
  }
  // Some builds provide decodeImage, some provide decodeImages
  const hasDecode = (typeof UTIF.decode === "function");
  const hasDecodeImage = (typeof UTIF.decodeImage === "function");
  const hasDecodeImages = (typeof UTIF.decodeImages === "function");

  if (!hasDecode || (!hasDecodeImage && !hasDecodeImages)) {
    const keys = Object.keys(UTIF).sort().join(", ");
    throw new Error(
      "UTIF loaded, but decodeImage/decodeImages not found. " +
      "Available keys: [" + keys + "]. " +
      "Check your UTIF script URL."
    );
  }

  const ifds = UTIF.decode(arrayBuffer);
  if (!ifds || ifds.length === 0) throw new Error("No IFDs found in TIFF.");

  const ifd = ifds[0];

  // decode raw samples into ifd.data
  if (hasDecodeImage) UTIF.decodeImage(arrayBuffer, ifd);
  else UTIF.decodeImages(arrayBuffer, ifds); // decodes all

  const w = ifd.width, h = ifd.height;
  if (!w || !h) throw new Error("Invalid TIFF size.");
  const nPix = w * h;

  const bitsArr = ifd["t258"];
  const bitsPerSample = Array.isArray(bitsArr) ? bitsArr[0] : (bitsArr || 8);
  const spp = ifd["t277"] || 1;        // SamplesPerPixel
  const sampleFormat = ifd["t339"] || 1; // 1=unsigned, 2=signed, 3=float

  // Prefer true grayscale samples
  if (spp === 1 && ifd.data) {
    const raw = ifd.data;

    // UTIF sometimes returns typed arrays directly
    if (raw instanceof Uint16Array && raw.length === nPix) {
      return reshape2D(raw, w, h);
    }
    if (raw instanceof Int16Array && raw.length === nPix) {
      return reshape2D(raw, w, h);
    }
    if (raw instanceof Float32Array && raw.length === nPix) {
      return reshape2D(raw, w, h);
    }

    // raw might be Uint8Array of sample bytes. Handle 8-bit and 16-bit explicitly.
    if (bitsPerSample === 8 && raw.length === nPix) {
      return reshape2D(raw, w, h);
    }

    if (bitsPerSample === 16) {
      // Expect 2*nPix bytes for 16-bit grayscale. If not, it's likely already been converted.
      if (raw.length === 2 * nPix) {
        const dv = new DataView(raw.buffer, raw.byteOffset, raw.byteLength);
        const flat = new Array(nPix);
        let bytePos = 0;
        for (let i = 0; i < nPix; i++) {
          let v;
          if (sampleFormat === 2) v = dv.getInt16(bytePos, true);
          else v = dv.getUint16(bytePos, true);
          flat[i] = v;
          bytePos += 2;
        }
        return reshape2D(flat, w, h);
      }

      // If we land here, your TIFF got decoded into something else (often RGBA8 path).
      // We'll fall back to RGBA8 rather than silently pretending it's 16-bit.
      console.warn(
        `TIFF says 16-bit, but raw length=${raw.length} (expected ${2*nPix}). ` +
        `Falling back to RGBA8 (will look like 8-bit).`
      );
    }
  }

  // Fallback: RGB/other TIFF -> RGBA8 (8-bit)
  if (typeof UTIF.toRGBA8 !== "function") throw new Error("UTIF.toRGBA8 not found for fallback.");
  const rgba = UTIF.toRGBA8(ifd);
  const z = new Array(h);
  let p = 0;
  for (let y = 0; y < h; y++) {
    const row = new Array(w);
    for (let x = 0; x < w; x++) {
      const r = rgba[p], g = rgba[p+1], b = rgba[p+2];
      row[x] = 0.299*r + 0.587*g + 0.114*b;
      p += 4;
    }
    z[y] = row;
  }
  return { width: w, height: h, z };
}

function reshape2D(flat, w, h) {
  const z = new Array(h);
  let p = 0;
  for (let y = 0; y < h; y++) {
    const row = new Array(w);
    for (let x = 0; x < w; x++) row[x] = flat[p++];
    z[y] = row;
  }
  return { width: w, height: h, z };
}

// ---------- geometry (LaVue-like 8 transforms) ----------
function applyGeometry(z, mode) {
  const h = z.length, w = z[0].length;

  const flipUD = () => {
    const out = new Array(h);
    for (let y = 0; y < h; y++) out[y] = z[h - 1 - y].slice();
    return { z: out, width: w, height: h };
  };

  const flipLR = () => {
    const out = new Array(h);
    for (let y = 0; y < h; y++) {
      const row = new Array(w);
      for (let x = 0; x < w; x++) row[x] = z[y][w - 1 - x];
      out[y] = row;
    }
    return { z: out, width: w, height: h };
  };

  const transpose = () => {
    const H2 = w, W2 = h;
    const out = new Array(H2);
    for (let y = 0; y < H2; y++) {
      const row = new Array(W2);
      for (let x = 0; x < W2; x++) row[x] = z[x][y];
      out[y] = row;
    }
    return { z: out, width: W2, height: H2 };
  };

  const rot90cw = () => {
    const H2 = w, W2 = h;
    const out = new Array(H2);
    for (let y = 0; y < H2; y++) {
      const row = new Array(W2);
      for (let x = 0; x < W2; x++) row[x] = z[h - 1 - x][y];
      out[y] = row;
    }
    return { z: out, width: W2, height: H2 };
  };

  const rot180 = () => {
    const out = new Array(h);
    for (let y = 0; y < h; y++) {
      const row = new Array(w);
      for (let x = 0; x < w; x++) row[x] = z[h - 1 - y][w - 1 - x];
      out[y] = row;
    }
    return { z: out, width: w, height: h };
  };

  const rot270cw = () => {
    const H2 = w, W2 = h;
    const out = new Array(H2);
    for (let y = 0; y < H2; y++) {
      const row = new Array(W2);
      for (let x = 0; x < W2; x++) row[x] = z[x][w - 1 - y];
      out[y] = row;
    }
    return { z: out, width: W2, height: H2 };
  };

  const rot180_transpose = () => {
    const H2 = w, W2 = h;
    const out = new Array(H2);
    for (let y = 0; y < H2; y++) {
      const row = new Array(W2);
      for (let x = 0; x < W2; x++) row[x] = z[h - 1 - x][w - 1 - y];
      out[y] = row;
    }
    return { z: out, width: W2, height: H2 };
  };

  switch (mode) {
    case "flipUD": return flipUD();
    case "flipLR": return flipLR();
    case "transpose": return transpose();
    case "rot90cw": return rot90cw();
    case "rot180": return rot180();
    case "rot270cw": return rot270cw();
    case "rot180_transpose": return rot180_transpose();
    case "none":
    default:
      return { z: z.map(r => r.slice()), width: w, height: h };
  }
}

function getColorScaleConfig(name) {
  if (name.endsWith("_r")) return { scale: name.slice(0, -2), reverse: true };
  return { scale: name, reverse: false };
}

// ---------- plot ----------
function plotImage() {
  if (!currentImage || !currentImage.z) {
    setStatus("No image loaded.", "red");
    return;
  }

  const colorOpt = document.getElementById("colorscale").value;
  const showColorbar = document.getElementById("showColorbar").checked;
  const logIntensity = document.getElementById("logIntensity").checked;
  const geomMode = document.getElementById("geomMode").value;

  const xMinUser = document.getElementById("xMin").value;
  const xMaxUser = document.getElementById("xMax").value;
  const yMinUser = document.getElementById("yMin").value;
  const yMaxUser = document.getElementById("yMax").value;
  const zMinUser = document.getElementById("zMin").value;
  const zMaxUser = document.getElementById("zMax").value;

  const geom = applyGeometry(currentImage.z, geomMode);
  const zGeom = geom.z;
  const width = geom.width, height = geom.height;

  // compute linear min/max from data
  let linMin = Infinity, linMax = -Infinity;
  for (let y = 0; y < height; y++) {
    const row = zGeom[y];
    for (let x = 0; x < width; x++) {
      const v = row[x];
      if (v == null || !isFinite(v)) continue;
      if (v < linMin) linMin = v;
      if (v > linMax) linMax = v;
    }
  }
  if (!isFinite(linMin) || !isFinite(linMax)) {
    setStatus("No valid intensity data.", "red");
    return;
  }

  // axis range
  let xMin = 0, xMax = width - 1, yMin = 0, yMax = height - 1;
  if (xMinUser !== "") xMin = parseFloat(xMinUser);
  if (xMaxUser !== "") xMax = parseFloat(xMaxUser);
  if (yMinUser !== "") yMin = parseFloat(yMinUser);
  if (yMaxUser !== "") yMax = parseFloat(yMaxUser);

  // intensity range (linear inputs)
  let zMinLinear = linMin, zMaxLinear = linMax;
  if (zMinUser !== "") zMinLinear = parseFloat(zMinUser);
  if (zMaxUser !== "") zMaxLinear = parseFloat(zMaxUser);
  if (!isFinite(zMinLinear)) zMinLinear = linMin;
  if (!isFinite(zMaxLinear)) zMaxLinear = linMax;
  if (zMaxLinear <= zMinLinear) zMaxLinear = zMinLinear + 1;

  // colorscale base
  let baseScale, reverse;
  if (colorOpt === "gray_clip") {
    baseScale = "Greys"; reverse = false;
  } else {
    ({ scale: baseScale, reverse } = getColorScaleConfig(colorOpt));
  }

  let zPlot, zmin, zmax, colorscale, reversescale, colorbar;

  // -------- linear mapping --------
  if (!logIntensity) {
    if (colorOpt === "gray_clip") {
      const delta = (zMaxLinear - zMinLinear) || 1;
      const zMaxPlot = zMaxLinear + delta; // reserve top for red
      zmin = zMinLinear;
      zmax = zMaxPlot;

      zPlot = new Array(height);
      for (let y = 0; y < height; y++) {
        const row = zGeom[y];
        const out = new Array(width);
        for (let x = 0; x < width; x++) {
          const v = row[x];
          if (!isFinite(v)) out[x] = null;
          else if (v <= zMinLinear) out[x] = zMinLinear;
          else if (v <= zMaxLinear) out[x] = v;
          else out[x] = zMaxPlot;
        }
        zPlot[y] = out;
      }

      const clipPos = (zMaxLinear - zMinLinear) / (zMaxPlot - zMinLinear);
      colorscale = [
        [0.0, "rgb(0,0,0)"],
        [Math.max(0, clipPos*0.999), "rgb(255,255,255)"],
        [clipPos, "rgb(255,255,255)"],
        [Math.min(clipPos + 1e-6, 0.999999), "rgb(255,0,0)"],
        [1.0, "rgb(255,0,0)"]
      ];
      reversescale = false;
      colorbar = { title: "Intensity (linear)" };
    } else {
      zPlot = zGeom;
      zmin = zMinLinear;
      zmax = zMaxLinear;
      colorscale = baseScale;
      reversescale = reverse;
      colorbar = { title: "Intensity (linear)" };
    }
  }
  // -------- log mapping: colorbar is log, inputs still linear --------
  else {
    let posMin = Infinity, posMax = -Infinity;
    for (let y = 0; y < height; y++) {
      const row = zGeom[y];
      for (let x = 0; x < width; x++) {
        const v = row[x];
        if (isFinite(v) && v > 0) {
          if (v < posMin) posMin = v;
          if (v > posMax) posMax = v;
        }
      }
    }
    if (!isFinite(posMin) || !isFinite(posMax)) {
      setStatus("No positive intensity values for log scale.", "red");
      return;
    }

    const zMinPos = Math.max(zMinLinear, posMin);
    const zMaxPos = Math.min(zMaxLinear, posMax);
    if (!(zMaxPos > zMinPos)) {
      setStatus("Invalid intensity range for log scale (need zMax > zMin and > 0).", "red");
      return;
    }

    const logMin = Math.log10(zMinPos);
    const logMax = Math.log10(zMaxPos);
    zmin = logMin;
    zmax = logMax;

    zPlot = new Array(height);
    for (let y = 0; y < height; y++) {
      const row = zGeom[y];
      const out = new Array(width);
      for (let x = 0; x < width; x++) {
        const v = row[x];
        out[x] = (isFinite(v) && v > 0) ? Math.log10(v) : null;
      }
      zPlot[y] = out;
    }

    const decadeMin = Math.ceil(logMin);
    const decadeMax = Math.floor(logMax);
    let tickvals = [], ticktext = [];
    if (decadeMax >= decadeMin) {
      for (let p = decadeMin; p <= decadeMax; p++) {
        tickvals.push(p);
        ticktext.push((Math.pow(10, p)).toExponential(1));
      }
    } else {
      tickvals = [logMin, logMax];
      ticktext = [zMinPos.toExponential(2), zMaxPos.toExponential(2)];
    }

    colorscale = (colorOpt === "gray_clip") ? "Greys" : baseScale;
    reversescale = (colorOpt === "gray_clip") ? false : reverse;

    colorbar = {
      title: "Intensity (log color scale)",
      tickmode: "array",
      tickvals: tickvals,
      ticktext: ticktext
    };
  }

  const trace = {
    z: zPlot,
    type: "heatmap",
    colorscale: colorscale,
    reversescale: reversescale,
    showscale: showColorbar,
    zmin: zmin,
    zmax: zmax,
    colorbar: colorbar
  };

  const layout = {
    margin: { l: 60, r: 10, t: 30, b: 60 },
    xaxis: { title: "X (pixels)", range: [xMin, xMax] },
    yaxis: { title: "Y (pixels)", range: [yMin, yMax], scaleanchor: "x" },
    dragmode: "zoom"
  };

  Plotly.newPlot("plot", [trace], layout, { responsive: true, displaylogo: false });

  const csName = (colorOpt === "gray_clip") ? "gray_clip-like" : baseScale;
  setStatus(
    `Plotted (${width} × ${height}), ${csName}${(reverse && colorOpt!=="gray_clip")?" (reversed)":""}${logIntensity?" [log]":""}. ` +
    `Data range (linear): [${linMin}, ${linMax}]`,
    "green"
  );
}

// ---------- home ----------
function resetView() {
  const plotDiv = document.getElementById("plot");
  if (!plotDiv || !plotDiv.data) return;
  Plotly.relayout(plotDiv, { "xaxis.autorange": true, "yaxis.autorange": true });
}
</script>

<hr>
<p class="note" style="text-align:center;">© 2025 Gaoming Zhu.</p>
</body>
</html>
