<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Schmid Factor Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
<h1>Schmid Factor Calculator</h1>

<p id="status" style="color:blue;">正在加载 Pyodide…</p>

<label>Euler1 (deg)：</label>
<input id="E1" type="number" value="10"><br>

<label>Euler2 (deg)：</label>
<input id="E2" type="number" value="11"><br>

<label>Euler3 (deg)：</label>
<input id="E3" type="number" value="12"><br><br>

<button onclick="runCalc()">计算</button>

<p id="result" style="margin-top:1em;"></p>

<img id="plot" style="max-width:400px;display:block;margin-top:10px;">

<hr>

<!-- Pyodide -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script>
// 1. 加载 Pyodide，并显式加载需要的 Python 包
let pyodideReadyPromise = (async () => {
  const pyodide = await loadPyodide({
    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.26.2/full/"
  });
  // 显式加载依赖包
  await pyodide.loadPackage(["numpy", "matplotlib"]);
  return pyodide;
})();

// 显示加载状态
(async () => {
  const status = document.getElementById("status");
  try {
    await pyodideReadyPromise;
    status.textContent = "Pyodide 加载完成，可以计算。";
  } catch (err) {
    console.error(err);
    status.textContent = "Pyodide 加载失败：" + err;
  }
})();

// 2. 点击“计算”按钮时运行
async function runCalc() {
  const E1 = parseFloat(document.getElementById("E1").value);
  const E2 = parseFloat(document.getElementById("E2").value);
  const E3 = parseFloat(document.getElementById("E3").value);

  const resultP = document.getElementById("result");
  const imgEl = document.getElementById("plot");

  imgEl.src = "";
  resultP.textContent = "正在计算…";

  try {
    let pyodide = await pyodideReadyPromise;

    // 把 JS 中的 Euler 角传入 Python 全局变量
    pyodide.globals.set("Euler1", E1);
    pyodide.globals.set("Euler2", E2);
    pyodide.globals.set("Euler3", E3);

    // 运行 Python 代码
    await pyodide.runPythonAsync(`
import numpy as np
import math, io, base64
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def Schmid(E0, E1, E2, hh, kk, ii, ll, uu, vv, tt, ww):
    time_unit_vector = 1
    Euler1rad = E0 * math.pi / 180
    Euler2rad = E1 * math.pi / 180
    Euler3rad = E2 * math.pi / 180

    gT11 = math.cos(Euler1rad) * math.cos(Euler3rad) - math.sin(Euler1rad) * math.sin(Euler3rad) * math.cos(Euler2rad)
    gT12 = -math.cos(Euler1rad) * math.sin(Euler3rad) - math.sin(Euler1rad) * math.cos(Euler3rad) * math.cos(Euler2rad)
    gT13 = math.sin(Euler1rad) * math.sin(Euler2rad)
    gT21 = math.sin(Euler1rad) * math.cos(Euler3rad) + math.cos(Euler1rad) * math.sin(Euler3rad) * math.cos(Euler2rad)
    gT22 = - math.sin(Euler1rad) * math.sin(Euler3rad) + math.cos(Euler1rad) * math.cos(Euler3rad) * math.cos(Euler2rad)
    gT23 = - math.cos(Euler1rad) * math.sin(Euler2rad)
    gT31 = math.sin(Euler3rad) * math.sin(Euler2rad)
    gT32 = math.cos(Euler3rad) * math.sin(Euler2rad)
    gT33 = math.cos(Euler2rad)
    gT = np.matrix([[gT11, gT12, gT13],  [gT21, gT22, gT23], [gT31, gT32, gT33]])
    g = gT.T
    sigmanormalized = np.matrix([[0, 0, 0], [0, 1, 0], [0, 0, 0]])
    gsigma = g * sigmanormalized
    gsigmagT = gsigma * gT

    hB1 = hh
    kB1 = kk
    iB1 = ii
    lB1 = ll
    uB1 = uu  
    vB1 = vv
    tB1 = tt
    wB1 = ww
    
    n1B1 = hB1
    n2B1 = (2 * kB1 + hB1)/(np.sqrt(3))
    n3B1 = lB1/1.62
    n4B1 = np.sqrt(n1B1 * n1B1 + n2B1 * n2B1 + n3B1 * n3B1)
    m1B1 = 1.5 * uB1
    m2B1 = np.sqrt(3)/2 *(2 * vB1 + uB1)
    m3B1 = wB1 * 1.62
    m4B1 = np.sqrt(m1B1 * m1B1 + m2B1 * m2B1 + m3B1 * m3B1)

    n1norB1 = n1B1/n4B1
    n2norB1 = n2B1/n4B1
    n3norB1 = n3B1/n4B1
    m1norB1 = m1B1/m4B1
    m2norB1 = m2B1/m4B1
    m3norB1 = m3B1/m4B1

    Burg01 = gT11 * m1norB1 + gT12 * m2norB1 + gT13 * m3norB1
    Burg02 = gT21 * m1norB1 + gT22 * m2norB1 + gT23 * m3norB1
    Burg03 = gT31 * m1norB1 + gT32 * m2norB1 + gT33 * m3norB1
    
    gTn1 = n1norB1*gT11 + n2norB1*gT12 + n3norB1*gT13
    gTn2 = n1norB1*gT21 + n2norB1*gT22 + n3norB1*gT23
    gTn3 = n1norB1*gT31 + n2norB1*gT32 + n3norB1*gT33
    
    plane_trace_x = (gTn2*1 - gTn3*0)*1
    plane_trace_y = (gTn3*0 - gTn1*1)*1
    
    minjB1 = np.matrix([[n1norB1*m1norB1, n2norB1*m1norB1, n3norB1*m1norB1],
                        [n1norB1*m2norB1, n2norB1*m2norB1, n3norB1*m2norB1],
                        [n1norB1*m3norB1, n2norB1*m3norB1, n3norB1*m3norB1]])

    bsB1 = (minjB1 + minjB1.T) * 0.5
    sfmatrixB1 = np.multiply(bsB1, gsigmagT)
    SFB1 = np.sum(sfmatrixB1)

    return (Burg01, Burg02, Burg03, SFB1, plane_trace_x, plane_trace_y)


def draw_slip(Euler1, Euler2, Euler3):
    hkil = np.matrix([
        [0,0,0,1,2,-1,-1,0], 
        [0,0,0,1,-1,2,-1,0],
        [0,0,0,1,-1,-1,2,0]
    ])

    for i in range(3):
        j = i
        _, _, _, _, px, py = Schmid(Euler1, Euler2, Euler3,
                                    hkil[j,0],hkil[j,1],hkil[j,2],hkil[j,3],
                                    hkil[j,4],hkil[j,5],hkil[j,6],hkil[j,7])
        plt.plot([px, -px], [py, -py], 'r')

# 画图
plt.figure(figsize=(6,6))
draw_slip(Euler1, Euler2, Euler3)
plt.xlim((-1.1,1.1))
plt.ylim((-1.1,1.1))
plt.axis('off')

buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=120)
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode("ascii")
plt.close()

sf1 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,2,-1,-1,0)[3]
sf2 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,-1,2,-1,0)[3]
sf3 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,-1,-1,2,0)[3]
`);

    // 从 Python 中取回结果
    const img_base64 = pyodide.globals.get("img_base64");
    const sf1 = pyodide.globals.get("sf1");
    const sf2 = pyodide.globals.get("sf2");
    const sf3 = pyodide.globals.get("sf3");

    resultP.textContent =
      "Basal Schmid factors: " +
      sf1.toFixed(3) + ", " +
      sf2.toFixed(3) + ", " +
      sf3.toFixed(3);

    imgEl.src = "data:image/png;base64," + img_base64;

  } catch (err) {
    console.error(err);
    resultP.textContent = "计算出错：" + err;
  }
}
</script>

</body>
</html>
