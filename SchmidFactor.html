<!DOCTYPE html>
<html lang="zh-CN">
<!--
Copyright (c) 2018-present Gaoming Zhu.

All rights reserved.

This webpage and its embedded Python code are the intellectual property of the author.
Redistribution, modification, or commercial use of the code in any form is strictly prohibited
without explicit written permission from the author.

For academic reference only.
-->
  
<head>
  <meta charset="UTF-8" />
  <title>Schmid Factor Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
<h1>Schmid Factor Calculator</h1>

<p id="status" style="color:blue;">正在加载 Pyodide…</p>

<label>Euler1 (deg)：</label>
<input id="E1" type="number" value="10"><br>

<label>Euler2 (deg)：</label>
<input id="E2" type="number" value="11"><br>

<label>Euler3 (deg)：</label>
<input id="E3" type="number" value="12"><br><br>

<button onclick="runCalc()">Calculate</button>

<p id="result" style="margin-top:1em;"></p>

<!-- 外层灰色正方形边框 -->
<div style="
    width:420px;
    height:420px;
    border:3px solid #888;
    margin-top:10px;
    display:flex;
    align-items:center;
    justify-content:center;
">
  <img id="plot" style="max-width:400px; max-height:400px;">
</div>

<hr>

<!-- Pyodide -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script>
// 1. 加载 Pyodide，并显式加载需要的 Python 包
let pyodideReadyPromise = (async () => {
  const pyodide = await loadPyodide({
    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.26.2/full/"
  });
  // 显式加载依赖包
  await pyodide.loadPackage(["numpy", "matplotlib"]);
  return pyodide;
})();

// 显示加载状态
(async () => {
  const status = document.getElementById("status");
  try {
    await pyodideReadyPromise;
    status.textContent = "Pyodide loaded successfully. Ready to calculate.";
  } catch (err) {
    console.error(err);
    status.textContent = "Pyodide 加载失败：" + err;
  }
})();

// 2. 点击“计算”按钮时运行
async function runCalc() {
  const E1 = parseFloat(document.getElementById("E1").value);
  const E2 = parseFloat(document.getElementById("E2").value);
  const E3 = parseFloat(document.getElementById("E3").value);

  const resultP = document.getElementById("result");
  const imgEl = document.getElementById("plot");

  imgEl.src = "";
  resultP.textContent = "Calculating…";

  try {
    let pyodide = await pyodideReadyPromise;

    // 把 JS 中的 Euler 角传入 Python 全局变量
    pyodide.globals.set("Euler1", E1);
    pyodide.globals.set("Euler2", E2);
    pyodide.globals.set("Euler3", E3);

    // 运行 Python 代码
    await pyodide.runPythonAsync(`


# -----------------------------------------------------------
# Copyright (c) 2018-present Gaoming Zhu
# All rights reserved.
#
# This Schmid factor calculation code is the intellectual
# property of the author. Redistribution, modification, or
# commercial use is prohibited without explicit permission.
# -----------------------------------------------------------

import numpy as np
import math, io, base64
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def Schmid(E0, E1, E2, hh, kk, ii, ll, uu, vv, tt, ww):
    time_unit_vector = 1
    Euler1rad = E0 * math.pi / 180
    Euler2rad = E1 * math.pi / 180
    Euler3rad = E2 * math.pi / 180

    gT11 = math.cos(Euler1rad) * math.cos(Euler3rad) - math.sin(Euler1rad) * math.sin(Euler3rad) * math.cos(Euler2rad)
    gT12 = -math.cos(Euler1rad) * math.sin(Euler3rad) - math.sin(Euler1rad) * math.cos(Euler3rad) * math.cos(Euler2rad)
    gT13 = math.sin(Euler1rad) * math.sin(Euler2rad)
    gT21 = math.sin(Euler1rad) * math.cos(Euler3rad) + math.cos(Euler1rad) * math.sin(Euler3rad) * math.cos(Euler2rad)
    gT22 = - math.sin(Euler1rad) * math.sin(Euler3rad) + math.cos(Euler1rad) * math.cos(Euler3rad) * math.cos(Euler2rad)
    gT23 = - math.cos(Euler1rad) * math.sin(Euler2rad)
    gT31 = math.sin(Euler3rad) * math.sin(Euler2rad)
    gT32 = math.cos(Euler3rad) * math.sin(Euler2rad)
    gT33 = math.cos(Euler2rad)
    gT = np.matrix([[gT11, gT12, gT13],  [gT21, gT22, gT23], [gT31, gT32, gT33]])
    g = gT.T
    sigmanormalized = np.matrix([[0, 0, 0], [0, 1, 0], [0, 0, 0]])
    gsigma = g * sigmanormalized
    gsigmagT = gsigma * gT

    hB1 = hh
    kB1 = kk
    iB1 = ii
    lB1 = ll
    uB1 = uu  
    vB1 = vv
    tB1 = tt
    wB1 = ww
    
    n1B1 = hB1
    n2B1 = (2 * kB1 + hB1)/(np.sqrt(3))
    n3B1 = lB1/1.62
    n4B1 = np.sqrt(n1B1 * n1B1 + n2B1 * n2B1 + n3B1 * n3B1)
    m1B1 = 1.5 * uB1
    m2B1 = np.sqrt(3)/2 *(2 * vB1 + uB1)
    m3B1 = wB1 * 1.62
    m4B1 = np.sqrt(m1B1 * m1B1 + m2B1 * m2B1 + m3B1 * m3B1)

    n1norB1 = n1B1/n4B1
    n2norB1 = n2B1/n4B1
    n3norB1 = n3B1/n4B1
    m1norB1 = m1B1/m4B1
    m2norB1 = m2B1/m4B1
    m3norB1 = m3B1/m4B1

    Burg01 = gT11 * m1norB1 + gT12 * m2norB1 + gT13 * m3norB1
    Burg02 = gT21 * m1norB1 + gT22 * m2norB1 + gT23 * m3norB1
    Burg03 = gT31 * m1norB1 + gT32 * m2norB1 + gT33 * m3norB1
    
    gTn1 = n1norB1*gT11 + n2norB1*gT12 + n3norB1*gT13
    gTn2 = n1norB1*gT21 + n2norB1*gT22 + n3norB1*gT23
    gTn3 = n1norB1*gT31 + n2norB1*gT32 + n3norB1*gT33
    
    plane_trace_x = (gTn2*1 - gTn3*0)*1
    plane_trace_y = (gTn3*0 - gTn1*1)*1
    
    minjB1 = np.matrix([[n1norB1*m1norB1, n2norB1*m1norB1, n3norB1*m1norB1],
                        [n1norB1*m2norB1, n2norB1*m2norB1, n3norB1*m2norB1],
                        [n1norB1*m3norB1, n2norB1*m3norB1, n3norB1*m3norB1]])

    bsB1 = (minjB1 + minjB1.T) * 0.5
    sfmatrixB1 = np.multiply(bsB1, gsigmagT)
    SFB1 = np.sum(sfmatrixB1)

    return (Burg01, Burg02, Burg03, SFB1, plane_trace_x, plane_trace_y)


def draw_slip(Euler1, Euler2, Euler3):
    hkil = np.matrix([[0,0,0,1,2,-1,-1,0], #basal
                      [0,0,0,1,-1,2,-1,0],
                      [0,0,0,1,-1,-1,2,0], 
                      [0,1,-1,0,2,-1,-1,0], #pri
                      [1,0,-1,0,-1,2,-1,0],
                      [-1,1,0,0,-1,-1,2,0],
                      [0,1,-1,1,2,-1,-1,0], #pyr_a
                      [1,0,-1,1,-1,2,-1,0],
                      [-1,1,0,1,-1,-1,2,0],
                      [0,-1,1,1,2,-1,-1,0],
                      [-1,0,1,1,-1,2,-1,0],
                      [1,-1,0,1,-1,-1,2,0],
                      [1,0,-1,1,2,-1,-1,-3], #pyr_ca
                      [1,0,-1,1,1,1,-2,-3],
                      [0,1,-1,1,1,1,-2,-3],
                      [0,1,-1,1,-1,2,-1,-3],
                      [-1,1,0,1,-1,2,-1,-3],
                      [-1,1,0,1,-2,1,1,-3],
                      [-1,0,1,1,-2,1,1,-3],
                      [-1,0,1,1,-1,-1,2,-3],
                      [0,-1,1,1,-1,-1,2,-3],
                      [0,-1,1,1,1,-2,1,-3],
                      [1,-1,0,1,1,-2,1,-3],
                      [1,-1,0,1,2,-1,-1,-3],
                      [2,-1,-1,2,2,-1,-1,-3],#pyrII_ca
                      [1,1,-2,2,1,1,-2,-3],
                      [-1,2,-1,2,-1,2,-1,-3],
                      [-2,1,1,2,-2,1,1,-3],
                      [-1,-1,2,2,-1,-1,2,-3],
                      [1,-2,1,2,1,-2,1,-3],
                      [1,0,-1,2,-1,0,1,1], #twin
                      [0,1,-1,2,0,-1,1,1],
                      [-1,1,0,2,1,-1,0,1],
                      [-1,0,1,2,1,0,-1,1],
                      [0,-1,1,2,0,1,-1,1],
                      [1,-1,0,2,-1,1,0,1]])
    
    for i in range(3):
        j = i + 0
        xxx1, xxx2, xxx3, xxx4, xxx5, xxx6 = Schmid(Euler1, Euler2, Euler3, hkil[j, 0], hkil[j, 1], hkil[j, 2], hkil[j, 3], hkil[j, 4], hkil[j, 5], hkil[j, 6], hkil[j, 7])
        pos_x, pos_y = xxx5, xxx6
        plt.plot([pos_x, -pos_x], [pos_y, -pos_y], c='r')
        if i == 1:
            plt.text(-pos_x, -pos_y, '1,2,3')
    
    for i in range(3):
        j = i + 3
        xxx1, xxx2, xxx3, xxx4, xxx5, xxx6 = Schmid(Euler1, Euler2, Euler3, hkil[j, 0], hkil[j, 1], hkil[j, 2], hkil[j, 3], hkil[j, 4], hkil[j, 5], hkil[j, 6], hkil[j, 7])
        pos_x, pos_y = xxx5, xxx6
        plt.plot([pos_x, -pos_x], [pos_y, -pos_y], c='b')
        plt.text(pos_x, pos_y, j+1)
    
    for i in range(6):
        j = i + 6
        xxx1, xxx2, xxx3, xxx4, xxx5, xxx6 = Schmid(Euler1, Euler2, Euler3, hkil[j, 0], hkil[j, 1], hkil[j, 2], hkil[j, 3], hkil[j, 4], hkil[j, 5], hkil[j, 6], hkil[j, 7])
        pos_x, pos_y = xxx5, xxx6
        plt.plot([pos_x, -pos_x], [pos_y, -pos_y], c='g')
        plt.text(pos_x, pos_y, j+1)
    
    for i in range(6):
        j = i + 24
        xxx1, xxx2, xxx3, xxx4, xxx5, xxx6 = Schmid(Euler1, Euler2, Euler3, hkil[j, 0], hkil[j, 1], hkil[j, 2], hkil[j, 3], hkil[j, 4], hkil[j, 5], hkil[j, 6], hkil[j, 7])
        pos_x, pos_y = xxx5, xxx6
        plt.plot([pos_x, -pos_x], [pos_y, -pos_y], c='darkblue')
        plt.text(pos_x, pos_y, j+1)
#    
    
    plt.scatter(0, 0, marker = 'o', facecolors='red', edgecolors='k', linewidth = 3, s = 10, alpha = 0.8)
    
# 画图
plt.figure(figsize=(4,4))
draw_slip(Euler1, Euler2, Euler3)
plt.xlim((-1.1,1.1))
plt.ylim((-1.1,1.1))
plt.axis('off')

buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=120)
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode("ascii")
plt.close()

sf1 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,2,-1,-1,0)[3]
sf2 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,-1,2,-1,0)[3]
sf3 = Schmid(Euler1,Euler2,Euler3,0,0,0,1,-1,-1,2,0)[3]
`);

    // 从 Python 中取回结果
    const img_base64 = pyodide.globals.get("img_base64");
    const sf1 = pyodide.globals.get("sf1");
    const sf2 = pyodide.globals.get("sf2");
    const sf3 = pyodide.globals.get("sf3");

    resultP.textContent =
      "Basal Schmid factors: " +
      sf1.toFixed(3) + ", " +
      sf2.toFixed(3) + ", " +
      sf3.toFixed(3);

    imgEl.src = "data:image/png;base64," + img_base64;

  } catch (err) {
    console.error(err);
    resultP.textContent = "计算出错：" + err;
  }
}
</script>
  
<hr>
<p style="text-align:center; color:gray; font-size:12px;">
  © 2018–present Gaoming Zhu. All rights reserved.
</p>

</body>
</html>
